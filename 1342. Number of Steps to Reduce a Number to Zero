1342. Number of Steps to Reduce a Number to Zero

Given a non-negative integer num, return the number of steps to reduce it to zero. If the current number is even, you have to 
divide it by 2, otherwise, you have to subtract 1 from it.

Input: num = 14
Output: 6
Explanation: 
Step 1) 14 is even; divide by 2 and obtain 7. 
Step 2) 7 is odd; subtract 1 and obtain 6.
Step 3) 6 is even; divide by 2 and obtain 3. 
Step 4) 3 is odd; subtract 1 and obtain 2. 
Step 5) 2 is even; divide by 2 and obtain 1. 
Step 6) 1 is odd; subtract 1 and obtain 0.


 
 
class Solution {
public:
    int RecurseCount(int num,int count)
    {
        if(num == 0)
            return count;
        if(num%2 == 0)
            return RecurseCount(num/2,++count);
        else
            return RecurseCount(num-1,++count);
    }
    
    int numberOfSteps (int num) {
        int count =0;
        int result = RecurseCount(num,count);
        return result;
    }
};

/* Things learnt
 ** Using recursion we can do this , easy problem. 
 ** Another way to solve this is by bit manipulation, very easy and effective
*/

To subtract 1 from an odd number means flipping a 1 to a 0.
To divide an even number by 2 means shifting right by one, dropping a 0.
After subtracting, you'll always get an even number
That means: (the number of steps required) = (the total number of bits used to represent the number) + (the number of 1 bits that are in there)

int numberOfSteps (int num) {
  return num == 0 ? 0 : log2(num) + bitset<32>(num).count();
}

There's one subtlety here. log2, when rounded down, actually returns (the number of bits used to represent a number) minus 1. 
But that's perfect for this, because we don't need to shift the last 0, so that balances out nicely. Also note that since log2(0) 
is undefined, we do have to handle that case separately.