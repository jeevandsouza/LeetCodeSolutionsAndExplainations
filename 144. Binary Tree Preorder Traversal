144. Binary Tree Preorder Traversal

Given the root of a binary tree, return the preorder traversal of its nodes' values

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void PreOrder(TreeNode* root,vector<int>&result)
    {
       if(!root)
           return;
        result.push_back(root->val);
         PreOrder(root->left,result);
        PreOrder(root->right,result);
    }
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int>result;
        PreOrder(root,result);
        return result;
    }
};



/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void MorrisTraversal(TreeNode* root,vector<int>&result)
    {
      while(root)
      {
          //Take the standard example of 1 2 3 4 5 by taking 1 as root, 2 and 3 as it's 
          //left and right child, 4 and 5 as left and right child of 2.
          //If the left child is null add the data to vector and move to right node
          if(root->left == NULL)
          {
              result.push_back(root->val);
              root = root->right;
          }
          else
          {
              /*I will take into account one iteration. First it checks if root is null
              but root is 1 so it move to this else part, here u find inorder predecessor 
              meaning take temp node add left child that would be 2 and loop until the 
              last right node that would be 5 , now temp has 5.Check if temp 5 is root if 
              not push the value of root that is 1 and the important part here put 1 to 
              the right side of 5 as a child and amke root as 2.
              */
              TreeNode* temp = root->left;
              while(temp->right && temp->right != root)
                  temp = temp->right;
              
              if(temp->right == root)
              {
                  temp->right = NULL;
                  root = root->right;
              }
              else
              {
                  result.push_back(root->val);
                  temp->right = root;
                  root = root->left;
              }
              
          }
      }
    }
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int>result;
        MorrisTraversal(root,result);
        return result;
    }
};

/* Things learnt
 ** First one is with recursion which uses O(n) space and time and the second one is morris traversal which takes lesser space 
complexity than recursive.
Algo for morris traversal
1...If left child is null, print the current node data. Move to right child.
….Else, Make the right child of the inorder predecessor point to the current node. Two cases arise:(Inorder predecessor is the right most child of the left subtree)
………a) The right child of the inorder predecessor already points to the current node. Set right child to NULL. Move to right child of current node.
………b) The right child is NULL. Set it to current node. Print current node’s data and move to left child of current node.
2...Iterate until current node is not NULL.
*/

